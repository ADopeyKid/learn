一、请说出下列最终的执行结果，并解释为什么?

```js
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
```

答案：10

解析：使用`var`定义这个i为全局的变量，是全局的作用域，当去执行`a[6]()`的时候，`for`循环已结束，并累加到10

二、请说出下列最终的执行结果，并解释为什么？

```js
var tmp = 123
if (true) {
  console.log(tmp)
  let tmp
}
```

答案：异常错误

解析：`{}`内的内容都是块级作用域，会读取`let`当中定义 `tmp`的值，但是`let`是定义了块级作用域，定义的变量不存在变量提升，需要先声明再使用，所以会输出错误

三、请详细说出var，let， const 三种声明变量的方式之间的具体差别？

答案：

var:

1. 使用`var` 在全局定义的变量为全局作用域，在函数内定义变量为函数作用域
2. `var`在非严谨模式下，会存在变量提升的现象，一开始没定义就使用会输出`undefined`
3. 在相同的作用域下重复定义同一个变量名，会出现覆盖的现象

let:

1. `let`用于定义变量
2. `let`定义的变量都为局部作用域，所声明的变量只能在所在代码块内有效，所声明的变量就会“锁死”在这个区域，不再受外部变量的影响
3. 不会和`var`一样存在变量提升的现象，必须要先定义在使用
4. `let`不允许在相同作用域內，重复声明同一个变量

const:

1. `const`用于定义常量，定义后的值为不能被修改（不允许修改变量指向的内存地址）
2. `const `定义的变量和`let`都为局部作用域，所声明的变量只能在所在代码块内有效，所声明的变量就会“锁死”在这个区域，不再受外部变量的影响
3. 和`let`一样不存存在变量提升的现象，必须要先定义在使用
4. 和`let`一样不允许在相同作用域內，重复声明同一个变量



四、请说出下面代码最终输出的结果，并解释为什么？

```js
var a = 10
var obj = {
  a: 20,
  fn () {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

答案：20

解析：箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值，当前的在`setTimeout`中使用了箭头函数，这里的`this`会指向它的上一级也就是`obj`，所以这里会输出`20`

五、结合ES6新语法，用最简单的方式找出数组中的最小值

```js
const arr = [12, 34, 42, 89, 4]
```

答案：

```js
Math.min(...arr)
```

六、简述`Symbol`的用途？

答案：

1. `Symbo`用于创建唯一的值，因为每一个创建出来的`Symbo`都是唯一的，可以用于定义对象中的key值，防止变量的冲突
2. 可以利用无法遍历出`Symbol`的特性，使用`Symbol`创建类的私有变量
3. 可以使用`Symbo`实现`Symbol.iterator`
4. 重置对象中的一些属性，如：`Symbol.toStringTag`、`Symbol.instanceof`等

七、说说什么是浅拷贝，什么是深拷贝？

答案：

浅拷贝：将原对象/数组的引用，赋予给一个新的对象/数组，当新对象/数组发生改变，原对象/数组也就发生改变，因为它们的内存地址，指向得是同一片推内存中

深拷贝：建立一个新的对象/数组，把原对象/数组中的值复制过去，原对象/数组发生改变，不会影响到拷贝的对象/数组，因为它们的指向的内存地址是不相同的

八、请简述`Typescript`与`Javascript`之间的关系

答案：`Typescript`是`Javascript`的超集，是`Javscript`的语法增强， 最终`Typescript`会把代码编译成浏览器可识别的`Javascript`代码

九、请谈谈你所认为的`Typescript`优缺点

答案：

优点：

1. Typescript在任何环境都可以运行
2. 功能更加强大，生态也更健康，更完善，越来越多的开源的项目都在使用Typescript，比如说Angular/Vue3.0
3. 静态输入，静态类型化是一种功能，可以在开发人员编写脚本时检测错误。查找并修复错误是当今开发团队的迫切需求。有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰
4. 更适合大型的项目，有时为了改进开发项目，需要对代码库进行小的增量更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构更变的容易、快捷
5. 更好地协作，当开发大型项目时，会有许多开发人员，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程

缺点：

1. Typescript本身的概念比Javascript更多，学习成本更大
2. 不适合小型维护周期小的项目，灵活度相对Javascript来说没这么高

十、描述引用计算数的工作原理和优缺点？

答案：

工作原理：一个对象如果它的引用指针为零就会被当做 “垃圾可回收的”，内部会存在一个引用的计数器，给每一个对象进行引用的计数，当引入之间的关系发生改变的时候，就会进行加1或者减1操作，当某个对象引用数为0的情况下，GC会自动进行内存的回收，引用计数算法的判断是否回收内存，唯一的判断标准就是引用计数值是否为0

优点：

1. 发现垃圾时立即回收
2. 最大限度减少程序暂停（由于引用计算算法是依据引入数是否为0去判断是否去释放内存的，它是时刻监控着引用，所以只要有“垃圾”，就会立即被释放，不容易因为内存不足而使程序暂停）

缺点：

1. 无法回收循环引用的对象, 两个对象被创建并且相互引用，因此创建了一个循环。在函数调用后，它们将离开作用域，所以它们事实上应该没有用并且要被释放。然而，引用计数算法认为既然两个对象最后一次相互引用了，它们都不会被垃圾回收。
2. 时间开销大（因为当前的引入计算要维护引用数值的变化，所以要时刻监控着这个数值，如果多个对象进行引入关系修改，时间开销会更大）

十一、描述标记整理算法的工作流程？

答案：

第一阶段：垃圾收集器会先从根出发，垃圾收集器会扫描遍历所有对象（根节点和子节点），活动对象（可达对象）标记为`”active“`(意味着不是垃圾)

第二阶段：垃圾收集器会遍历所有没有被标记的对象，它会认为是垃圾，先执行整理，移动活动对象位置，让它们在内存地址上连续，释放所有“垃圾”的内存，同时会把释放的空间放到一个空闲列表里面去，方便后面的内存空间进行申请空间使用

十二、描述V8中新生代存储区垃圾回收的流程？

答案：

V8引擎垃圾新生代引擎主要采用复制算法 + 标记整理的算法，在新生代的内存区域当中也被分为了两个相当大小的空间，使用的空间为From，空闲的空间为To，活动对象是存储在From的空间当中，当活动对象被标记完成后，会对内存空间进行整理，当整理过后会把活动对象拷贝至To的空间当中，再进行Form与To空间进行交换，From内的空间进行释放掉。

在拷贝的过程当中可能会出现晋升（晋升就是将新生代的对象移动到老生代的空间），晋升需要满足以下两个条件：

1. 一轮GC还存活的新生代对象
2. To空间的使用率超过25%

十三、描述增量标记算法在何时使用及工作原理？

答案：采用增量标记算法是为了进行效率的优化，在程序的执行过程当中，GC可能会会进行垃圾回收的操作，这个过程当中程序的执行是暂停的，而增量标记的算法就是标记清除算法的增强，就是把垃圾回收标记的过程拆分为多次进行，组合得去完成此次垃圾回收，让垃圾回收和程序执行交替地去完成，这样子对时间的消耗会更加合理